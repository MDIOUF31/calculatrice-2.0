# -*- coding: utf-8 -*-
"""calculator_2.0

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xlVXmBcdgWYYVSeB1dnH_BW7NGY21uo9
"""

import math
#Creation classe "calculatrice"
class Calculatrice:
#"init" qui initialise le dictionnaire avec les opérations mathématiques de base (+, -, *, /) et les fonctions correspondantes
    def __init__(self):
        self.operations = {
            '+': self.addition,
            '-': self.soustraction,
            '*': self.multiplication,
            '/': self.division,
            'log': self.logarithme,
            'sqrt': self.racine_carree
        }

    def addition(self, x, y):
        return x + y

    def soustraction(self, x, y):
        return x - y

    def multiplication(self, x, y):
        return x * y

    def division(self, x, y):
        if y == 0:
          return ("Division par zéro est interdite.")
        else:
          return x / y

    def logarithme(self, x):
        if x <= 0:
          return ("Le logarithme est défini que pour les nombres positifs.")
        else:
          return math.log(x)

    def racine_carree(self, x):
        if x < 0:
          return ("La racine carrée est définie que pour les nombres positifs.")
        else:
          return math.sqrt(x)
 # Une méthode appelée "add_operation" qui prend deux arguments : le symbole de l'opération et la fonction correspondante
    def add_operation(self, symbole, fonction):

        self.operations[symbole] = fonction

    def calculer(self, operation1, x, operation2, y):
        # Vérifier si operation1 est valide
        if operation1 not in self.operations and operation1 != '':
            print("Opération 1 non valide.")
            return None

        # Vérifier si operation2 est valide
        if operation2 not in self.operations and operation2 != '':
            print("Opération 2 non valide.")
            return None

        # Vérifier si x et y sont des nombres
        if not (isinstance(x, (int, float)) and isinstance(y, (int, float))):
            print("Les entrées doivent être des nombres.")
            return None

        # Appeler les fonctions correspondantes et retourner le résultat
        if operation1:
            fonction1 = self.operations[operation1]
            resultat1 = fonction1(x)
        else:
            resultat1 = x

        if operation2:
            fonction2 = self.operations[operation2]
            resultat2 = fonction2(y)
        else:
            resultat2 = y

        return resultat1, resultat2

# Création d'une instance de la classe Calculatrice
calculatrice = Calculatrice()
#une boucle while qui permet à l'utilisateur de continuer à effectuer des calculs jusqu'à ce qu'il choisisse de quitter.
while True:
    # Étape 1 : Demander à l'utilisateur s'il souhaite un symbole pour le premier nombre
    choix1 = input("Souhaitez-vous placer un symbole devant le premier nombre (oui/non) ? ")
    if choix1.lower() != 'oui':
        operation1 = ''
        x = float(input("Entrez le premier nombre : "))
    else:
        operation1 = input("Choisissez un symbole (log, sqrt) pour le premier nombre : ")
        x = float(input("Entrez le premier nombre : "))

    # Étape 2 : Demander à l'utilisateur de choisir l'opération
    operation = input("Choisissez une opération (+, -, *, /) : ")

    # Étape 3 : Demander à l'utilisateur s'il souhaite un symbole pour le deuxième nombre
    choix2 = input("Souhaitez-vous placer un symbole devant le deuxième nombre (oui/non) ? ")
    if choix2.lower() != 'oui':
        operation2 = ''
        y = float(input("Entrez le deuxième nombre : "))
    else:
        operation2 = input("Choisissez un symbole (log, sqrt) pour le deuxième nombre : ")
        y = float(input("Entrez le deuxième nombre : "))

    # Étape 4 : Calculer le résultat
    resultat = calculatrice.calculer(operation1, x, operation2, y)
    if resultat is not None:
        if operation1:
            resultat_intermediaire = f"{resultat[0]} {operation} {resultat[1]}"
            resultat_final = eval(resultat_intermediaire)
            print(f"Résultat ({operation1}({x})) {operation} ({operation2}({y})) = {resultat_intermediaire}")
            print(f"Le résultat final de votre opération = {resultat_final}")
        else:
            resultat_intermediaire = f"{x} {operation} {resultat[1]}"
            resultat_final = eval(resultat_intermediaire)
            print(f"Résultat {x} {operation} ({operation2}({y})) = {resultat_intermediaire}")
            print(f"Le résultat final de votre opération = {resultat_final}")

    # Demander à l'utilisateur s'il souhaite continuer
    continuer = input("Voulez-vous effectuer une autre opération (oui/non) ? ")
    if continuer.lower() != 'oui':
        break